# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_struct.ipynb.

# %% auto 0
__all__ = []

# %% ../nbs/00_struct.ipynb 3
import re
import json

from claudette.core import *
from fastcore.utils import *
from fastcore.meta import delegates
from pydantic import BaseModel, Field, ValidationError

# %% ../nbs/00_struct.ipynb 9
@patch(cls_method=True)
def claude_schema(cls: BaseModel):
    "Create tool schema for claude"
    def _filter_title(obj):
        if isinstance(obj, dict): return {k:_filter_title(v) for k,v in obj.items() if k != 'title'}
        elif isinstance(obj, list): return [_filter_title(item) for item in obj]
        else: return obj

    schema = cls.model_json_schema()
    name = schema.pop('title')
    try:
        description = schema.pop('description')
    except KeyError:
        raise KeyError("Provide a docstring")
    return {
        "name": name,
        "description": description,
        "input_schema": _filter_title(schema)
    }

# %% ../nbs/00_struct.ipynb 16
def _escape_json_newlines(json_string):
    def replace_newline(match):
        if match.group(1):  # Inside a string
            return match.group(1).replace('\n', '\\n')
        else:  # Outside a string
            return match.group(0)

    pattern = r'("(?:[^"\\]|\\.)*")|\n'
    return re.sub(pattern, replace_newline, json_string)

def _mk_struct(inp, resp_model) -> BaseModel:
    try:
        return resp_model(**inp)
    except ValidationError:
        return resp_model(**{
            k: json.loads(_escape_json_newlines(v)) for k,v in inp.items()
        })


# %% ../nbs/00_struct.ipynb 17
@patch
@delegates(Client.__call__)
def struct(self:Client,
             msgs:list, # List of messages in the dialog
             resp_model: type[BaseModel], # Non-initialized pydantic struct
             **kwargs
          ) -> BaseModel: # Initialized pydantic struct
    "Parse Claude output into the Pydantic `resp_model`"
    kwargs["tool_choice"] = mk_tool_choice(resp_model.__name__)
    kwargs["tools"] = [resp_model.claude_schema()] # no other tools needed -- model is forced by tool_choice
    fc = self(msgs=msgs, **kwargs)
    res = _mk_struct(contents(fc).input, resp_model)
    return res

# %% ../nbs/00_struct.ipynb 23
@patch
@delegates(Client.struct)
def struct(self:Chat,
             resp_model: type[BaseModel], # Non-initialized pydantic struct
             treat_as_output=True, # Usually using a tool
             **kwargs) -> BaseModel:
    self._append_pr(kwargs.pop("pr", None))
    res = self.c.struct(self.h, resp_model=resp_model, **kwargs)
    if treat_as_output:
        msgs = [mk_msg(repr(res), "assistant")] # alternatively: res.json()
    else:
        r = self.c.result
        tool_id = contents(r).id
        msgs = [mk_msg(r, "assistant"),
                mk_msg([mk_funcres(tool_id, repr(res))], "user")]
    self.h += msgs
    return res
