[
  {
    "objectID": "examples/pet_store.html",
    "href": "examples/pet_store.html",
    "title": "Pet Store Sales-Customer Loop",
    "section": "",
    "text": "from claudette.core import *\nimport claudette_pydantic\nfrom pydantic import BaseModel, Field, create_model\nfrom typing import List, Union, Literal, Type\nfrom textwrap import dedent\nimport json\n\nLet’s create some pets\n\nclass Pet(BaseModel):\n    name: str\n    price: float = Field(description=\"Full price of the Pet\")\n\nclass Dog(Pet):\n    type: Literal[\"dog\"] = \"dog\"\n    breed: str\n\nclass Fish(Pet):\n    type: Literal[\"fish\"] = \"fish\"\n    species: str\n    tank_size: float\n\ndogs = [Dog(name=\"Buddy\", breed=\"Labrador\", price=500), Dog(name=\"Max\", breed=\"German Shepherd\", price=600)]\nfish = [Fish(name=\"Nemo\", species=\"Clownfish\", price=110, tank_size=20), Fish(name=\"Bubbles\", species=\"Betta\", price=300, tank_size=5)]\n\nAnd a rather elaborate salesperson, where the Salesperson has information about the pet shop inventory. They can do actions:\n\nMessage: just send a message to customer\nOffer: send a offer for a pet, the pet object is nested in the offer along with the proposed price\n\nI then set the docstring of the returned function through __doc__ this gives private information to the salesperson about the inventory and prices, without ti being revealed in the message history.\n\nclass SalesPersonMessage(BaseModel):\n    \"The salesperson should first talk to the customer to find their budget and negotiate the best deal for a pet\"\n    type: Literal[\"message\"] = \"message\"\n    content: str\n\nclass SalespersonOffer(BaseModel):\n    \"Send a SellOffer once a pet at a proposed price has informally been agreed upon.\"\n    type: Literal[\"offer\"] = \"offer\"\n    pet: Union[Dog, Fish] = Field(..., discriminator='type')\n    price: float\n\nclass SalespersonAction(BaseModel):\n    action: Union[SalesPersonMessage, SalespersonOffer] = Field(..., discriminator='type')\n\nclass SalespersonInfo(BaseModel):\n    name: str\n    inventory: List[Union[Dog, Fish]] = Field(..., description=\"List of pets available for sale\")\n\n\n    def create_custom_action(self) -&gt; Type[SalespersonAction]:\n        CustomSalespersonAction = create_model(\n            \"CustomSalespersonAction\",\n            __base__=SalespersonAction,\n        )\n\n        inventory_pretty = '- ' + '\\n- '.join(repr(o) for o in self.inventory)\n\n        CustomSalespersonAction.__doc__ = dedent(f\"\"\"\\\n        Represents a salesperson in the pet store simulation.\n\n        The salesperson has access to a list of pets (dogs and fish) available in the store,\n        but does not know the customer's budget or preferences. The salesperson's goal is\n        to make a sale to maximizes profit.\n\n        ## Discounts\n\n        May offer a 10% discount on all pets\n        25% on FISH ONLY\n\n        ## Sales\n\n        You should sell the pet included ONLY. Do not sell accessories, only the items currently in inventory.\n\n        ## Details\n\n        Perform an action based on conversation history and salesperson details.\n\n        Salesperson details:\n        Name: {self.name}\n\n        Inventory:\n        {inventory_pretty}\"\"\")\n\n        return CustomSalespersonAction\n\nsalesperson = SalespersonInfo(name=\"Bob\", inventory=dogs + fish)\n\nCustomer is similar, with a budget and a pet preference. Actions:\n\nMessage\nLeave\nOn salesperson offer, can choose to accept\n\nNotably the customers budget is hidden from the salesperson, and the inventory is hidden from the customer, so they must communicate to come to an agreement.\n\nclass CustomerOfferResponse(BaseModel):\n    \"\"\"Determine whether to accept the sale.\n    Accept only if the offer is consistent to a previously agreed sale.\n    this may **only** be given as an immediate response to a SellOffer\"\"\"\n    type: Literal[\"offer\"] = \"offer\"\n    accept: bool\n\nclass CustomerOfferAction(BaseModel):\n    action: CustomerOfferResponse\n\nclass CustomerMessage(BaseModel):\n    type: Literal[\"message\"] = \"message\"\n    content: str\n\nclass CustomerLeave(BaseModel):\n    \"If all other avenues are exhausted, nothing in the store is acceptable, you may leave the store\"\n    type: Literal[\"leave\"] = \"leave\"\n\nclass CustomerAction(BaseModel):\n    action: Union[CustomerMessage, CustomerLeave] = Field(..., discriminator='type')\n\n\nclass CustomerInfo(BaseModel):\n    name: str\n    pet_preference: str = Field(..., description=\"The type of pet the customer prefers ('dog' or 'fish')\")\n    budget: float = Field(..., description=\"The maximum amount the customer is willing to spend\")\n\n    def create_custom_action(self, offer=False) -&gt; Type[CustomerAction]:\n        CustomCustomerAction = create_model(\n            \"CustomCustomerAction\",\n            __base__=CustomerOfferAction if offer else CustomerAction,\n        )\n\n        CustomCustomerAction.__doc__ = dedent(f\"\"\"\\\n        Represents a customer in the pet store simulation.\n\n        The customer has a pet preference and a budget, but does not know what pets\n        the store has in stock or their prices. The customer's goal is to negotiate\n        the best deal for their preferred type of pet within their budget.\n\n        Perform an action based on conversation history and customer details.\n\n        Customer Information:\n        - Name: {self.name}\n        - Pet Preference: {self.pet_preference}\n        - Budget: ${self.budget}\n        \"\"\")\n\n        return CustomCustomerAction\n\n\npet_preference = f\"\"\"\\\nAlice really wants a dog, but has a hard limit of 100 dollars.\nShe may also be open to buying a fish\"\"\"\n\ncustomer = CustomerInfo(name=\"Alice\", pet_preference=pet_preference, budget=100)\n\nThen I set up a similar loop to Chat.toolloop but exits on a successful offer or leaving.\n\nsp = \"\"\"\\\nYou are participating in a role-playing simulation of a pet store negotiation.\nIf you are the customer, your goal is to purchase your preferred pet within your budget.\nIf you are the salesperson, your goal is to make a profitable sale while ensuring customer satisfaction.\nBe friendly and professional, but also try to get the best deal for yourself.\n\nThe negotiation continues until a sale is agreed upon or one party decides to end the conversation.\nYou should be polite, but do not discuss the specifics of the pets, work out a sale based on price and pet preferences. Each response should be 3 sentences max.\n\"\"\"\n\n\ndef chat_loop(model, steps): # similar to Chat.toolloop\n    chat = Chat(model, sp=sp)\n    responses = []\n    res = None\n    for i in range(steps):\n        if i == 0: # prompt required to switch to assistant\n            pr = \"A customer walks into a store\"\n        else:\n            pr = None\n\n        if i % 2 == 0:\n            role = \"salesperson\"\n            s = salesperson.create_custom_action()\n        else:\n            role = \"customer\"\n            if res is not None and res.action.type == 'offer':\n                offer = True\n            else:\n                offer = False\n            s = customer.create_custom_action(offer)\n\n        res = chat.struct(s, treat_as_output=False, pr=pr)\n        responses.append(res)\n        if res.action.type == 'message':\n            print(f\"{role}: {res.action.content}\\n\")\n        if i % 2 == 1:\n            if res.action.type == 'offer' and res.action.accept:\n                return responses[-2].action\n            elif res.action.type == 'leave':\n                return responses[-1].action\n    return None\n\ndef sim(model, steps):\n    print(f\"Model: {model} | Steps: {steps}\\n=====\\n\")\n    res = chat_loop(model, steps)\n    if res is None:\n        print(\"Timeout\")\n    elif res.type == 'offer':\n        print(\"Sold:\", repr(res))\n    elif res.type == 'leave':\n        print(\"Customer left.\")\n    else:\n        raise ValueError(\"invalid return\", res)\n\nSet up so that Alice can not afford a dog, and can only afford a fish with discount. Haiku figures it out.\nThere’s a shared history between them, but individuals history is kept hidden inside the struct description for each step\n\nsim(models[-1], 20)\n\nModel: claude-3-haiku-20240307 | Steps: 20\n=====\n\nsalesperson: Hello, welcome to our pet store! How can I assist you today?\n\ncustomer: Hi, I'm looking to buy a pet. I really want a dog, but my budget is only $100. Do you have any dogs in that price range?\n\nsalesperson: Unfortunately, we don't have any dogs in that price range. Our dogs start at $500. However, we do have some nice fish that would fit your budget. Let me show you what we have in stock.\n\ncustomer: Hmm, I was really hoping for a dog. But I guess I could consider a fish if the price is right. What kind of fish do you have and how much do they cost?\n\nsalesperson: Great, let me show you our fish options. We have a Clownfish named Nemo for $110 and a Betta fish named Bubbles for $300. The Clownfish would be a better fit for your $100 budget.\n\ncustomer: Okay, the Clownfish Nemo sounds good. I think I'll go with that one. Can we negotiate the price a bit to get it closer to my $100 budget?\n\nSold: SalespersonOffer(type='offer', pet=Fish(name='Nemo', price=110.0, type='fish', species='Clownfish', tank_size=20.0), price=99.0)",
    "crumbs": [
      "examples",
      "Pet Store Sales-Customer Loop"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "claudette-pydantic",
    "section": "",
    "text": "Adds Pydantic support for claudette through function calling\nclaudette_pydantic provides the struct method in the Client and Chat of claudette\nstruct provides a wrapper around __call__. Provide a Pydantic BaseModel as schema, and the model will return an initialized BaseModel object.\nI’ve found Haiku to be quite reliable at even complicated schemas.",
    "crumbs": [
      "claudette-pydantic"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "claudette-pydantic",
    "section": "Install",
    "text": "Install\npip install claudette-pydantic",
    "crumbs": [
      "claudette-pydantic"
    ]
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "claudette-pydantic",
    "section": "Getting Started",
    "text": "Getting Started\n\nfrom claudette.core import *\nimport claudette_pydantic # patches claudette with `struct`\nfrom pydantic import BaseModel, Field\nfrom typing import Literal, Union, List\n\n\nmodel = models[-1]\nmodel\n\n'claude-3-haiku-20240307'\n\n\n\nclass Pet(BaseModel):\n    \"Create a new pet\"\n    name: str\n    age: int\n    owner: str = Field(default=\"NA\", description=\"Owner name. Do not return if not given.\")\n    type: Literal['dog', 'cat', 'mouse']\n\nc = Client(model)\nprint(repr(c.struct(msgs=\"Can you make a pet for my dog Mac? He's 14 years old\", resp_model=Pet)))\nprint(repr(c.struct(msgs=\"Tom: my cat is juma and he's 16 years old\", resp_model=Pet)))\n\nPet(name='Mac', age=14, owner='NA', type='dog')\nPet(name='juma', age=16, owner='Tom', type='cat')",
    "crumbs": [
      "claudette-pydantic"
    ]
  },
  {
    "objectID": "index.html#going-deeper",
    "href": "index.html#going-deeper",
    "title": "claudette-pydantic",
    "section": "Going Deeper",
    "text": "Going Deeper\nI pulled this example from pydantic docs has a list of discriminated unions, shown by pet_type. For each object the model is required to return different things.\nYou should be able to use the full power of Pydantic here. I’ve found that instructor for Claude fails on this example.\nEach sub BaseModel may also have docstrings describing usage. I’ve found prompting this way to be quite reliable.\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    meows: int\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    barks: float\n\n\nclass Reptile(BaseModel):\n    pet_type: Literal['lizard', 'dragon']\n    scales: bool\n\n# Dummy to show doc strings\nclass Create(BaseModel):\n    \"Pass as final member of the `pet` list to indicate success\"\n    pet_type: Literal['create']\n\nclass OwnersPets(BaseModel):\n    \"\"\"\n    Information for to gather for an Owner's pets\n    \"\"\"\n    pet: List[Union[Cat, Dog, Reptile, Create]] = Field(..., discriminator='pet_type')\n\nchat = Chat(model)\npr = \"hello I am a new owner and I would like to add some pets for me. I have a dog which has 6 barks, a dragon with no scales, and a cat with 2 meows\"\nprint(repr(chat.struct(OwnersPets, pr=pr)))\nprint(repr(chat.struct(OwnersPets, pr=\"actually my dragon does have scales, can you change that for me?\")))\n\nOwnersPets(pet=[Dog(pet_type='dog', barks=6.0), Reptile(pet_type='dragon', scales=False), Cat(pet_type='cat', meows=2), Create(pet_type='create')])\nOwnersPets(pet=[Dog(pet_type='dog', barks=6.0), Reptile(pet_type='dragon', scales=True), Cat(pet_type='cat', meows=2), Create(pet_type='create')])\n\n\nWhile the struct uses tool use to enforce the schema, we save in history as the repr response to keep the user,assistant,user flow.\n\nchat.h\n\n[{'role': 'user',\n  'content': [{'type': 'text',\n    'text': 'hello I am a new owner and I would like to add some pets for me. I have a dog which has 6 barks, a dragon with no scales, and a cat with 2 meows'}]},\n {'role': 'assistant',\n  'content': [{'type': 'text',\n    'text': \"OwnersPets(pet=[Dog(pet_type='dog', barks=6.0), Reptile(pet_type='dragon', scales=False), Cat(pet_type='cat', meows=2), Create(pet_type='create')])\"}]},\n {'role': 'user',\n  'content': [{'type': 'text',\n    'text': 'actually my dragon does have scales, can you change that for me?'}]},\n {'role': 'assistant',\n  'content': [{'type': 'text',\n    'text': \"OwnersPets(pet=[Dog(pet_type='dog', barks=6.0), Reptile(pet_type='dragon', scales=True), Cat(pet_type='cat', meows=2), Create(pet_type='create')])\"}]}]\n\n\nAlternatively you can use struct as tool use flow with treat_as_output=False (but requires the next input to be assistant)\n\nchat.struct(OwnersPets, pr=pr, treat_as_output=False)\nchat.h[-3:]\n\n[{'role': 'user',\n  'content': [{'type': 'text',\n    'text': 'hello I am a new owner and I would like to add some pets for me. I have a dog which has 6 barks, a dragon with no scales, and a cat with 2 meows'}]},\n {'role': 'assistant',\n  'content': [ToolUseBlock(id='toolu_015ggQ1iH6BxBffd7erj3rjR', input={'pet': [{'pet_type': 'dog', 'barks': 6.0}, {'pet_type': 'dragon', 'scales': False}, {'pet_type': 'cat', 'meows': 2}]}, name='OwnersPets', type='tool_use')]},\n {'role': 'user',\n  'content': [{'type': 'tool_result',\n    'tool_use_id': 'toolu_015ggQ1iH6BxBffd7erj3rjR',\n    'content': \"OwnersPets(pet=[Dog(pet_type='dog', barks=6.0), Reptile(pet_type='dragon', scales=False), Cat(pet_type='cat', meows=2)])\"}]}]\n\n\n(So I couldn’t prompt it again here, next input would have to be an assistant)\n\nUser Creation & few-shot examples\nYou can even add few shot examples for each input\n\nclass User(BaseModel):\n    \"User creation tool\"\n    age: int = Field(description='Age of the user')\n    name: str = Field(title='Username')\n    password: str = Field(\n        json_schema_extra={\n            'title': 'Password',\n            'description': 'Password of the user',\n            'examples': ['Monkey!123'],\n        }\n    )\nprint(repr(c.struct(msgs=[\"Can you create me a new user for tom age 22\"], resp_model=User, sp=\"for a given user, generate a similar password based on examples\")))\n\nUser(age=22, name='tom', password='Monkey!123')\n\n\nUses the few-shot example as asked for in the system prompt.\n\n\nYou can find more examples nbs/examples",
    "crumbs": [
      "claudette-pydantic"
    ]
  },
  {
    "objectID": "index.html#signature",
    "href": "index.html#signature",
    "title": "claudette-pydantic",
    "section": "Signature:",
    "text": "Signature:\nClient.struct(\n    self: claudette.core.Client,\n    msgs: list,\n    resp_model: type[BaseModel], # non-initialized Pydantic BaseModel\n    **, # Client.__call__ kwargs...\n) -&gt; BaseModel\nChat.struct(\n    self: claudette.core.Chat,\n    resp_model: type[BaseModel], # non-initialized Pydantic BaseModel\n    treat_as_output=True, # In chat history, tool is reflected\n    **, # Chat.__call__ kwargs...\n) -&gt; BaseModel",
    "crumbs": [
      "claudette-pydantic"
    ]
  },
  {
    "objectID": "struct.html",
    "href": "struct.html",
    "title": "Structured Output with Pydantic",
    "section": "",
    "text": "import os\n# os.environ['ANTHROPIC_LOG'] = 'debug'\n\n\nmodel = models[1] # sonnet -- haiku was quite flaky on the failure cases.\n\nPydantic provides a way of extracting structured outputs from text. This is useful for integrating an LLM as a single component of a pipeline.\nMuch of this was inspired by Instructor.\nAnthropic function calling is based on JSON Schema (with a few small tweaks). You can easily get the the JSON Schema from any Pydantic mdoel with the model_json_schema classmethod.\n\nclass User(BaseModel):\n    \"Create a new user\"\n    username: str\n    password: str\n    email: str\n    success: bool  = Field(..., description=\"Indicate if user creation is a success.\")\n    failure_reason: str = Field(default=\"\", description=\"Failure reason. This should be \\\"\\\" if `success=True`. If `success=False` you **must** give a failure reason.\")\n\nUser.model_json_schema()\n\n{'description': 'Create a new user',\n 'properties': {'username': {'title': 'Username', 'type': 'string'},\n  'password': {'title': 'Password', 'type': 'string'},\n  'email': {'title': 'Email', 'type': 'string'},\n  'success': {'description': 'Indicate if user creation is a success.',\n   'title': 'Success',\n   'type': 'boolean'},\n  'failure_reason': {'default': '',\n   'description': 'Failure reason. This should be \"\" if `success=True`. If `success=False` you **must** give a failure reason.',\n   'title': 'Failure Reason',\n   'type': 'string'}},\n 'required': ['username', 'password', 'email', 'success'],\n 'title': 'User',\n 'type': 'object'}\n\n\nNotable differences between JSON Schema and Anthropic’s function calling:\n\ntitle -&gt; name\nproperties -&gt; input_schema: { properties }\nNo title in parameters, instead key is used.\n\nI’m not really sure why they’d break a spec for such small differences. We can create a new claude_schema based on model_json_schema.\n\nsource\n\nBaseModel.claude_schema\n\n BaseModel.claude_schema ()\n\nCreate tool schema for claude\n\n\nExported source\n@patch(cls_method=True)\ndef claude_schema(cls: BaseModel):\n    \"Create tool schema for claude\"\n    def _filter_title(obj):\n        if isinstance(obj, dict): return {k:_filter_title(v) for k,v in obj.items() if k != 'title'}\n        elif isinstance(obj, list): return [_filter_title(item) for item in obj]\n        else: return obj\n\n    schema = cls.model_json_schema()\n    name = schema.pop('title')\n    try:\n        description = schema.pop('description')\n    except KeyError:\n        raise KeyError(\"Provide a docstring\")\n    return {\n        \"name\": name,\n        \"description\": description,\n        \"input_schema\": _filter_title(schema)\n    }\n\n\n\nUser.claude_schema()\n\n{'name': 'User',\n 'description': 'Create a new user',\n 'input_schema': {'properties': {'username': {'type': 'string'},\n   'password': {'type': 'string'},\n   'email': {'type': 'string'},\n   'success': {'description': 'Indicate if user creation is a success.',\n    'type': 'boolean'},\n   'failure_reason': {'default': '',\n    'description': 'Failure reason. This should be \"\" if `success=True`. If `success=False` you **must** give a failure reason.',\n    'type': 'string'}},\n  'required': ['username', 'password', 'email', 'success'],\n  'type': 'object'}}\n\n\nJust using claude_schema, we can now use Pydantic models using only our existing tools:\n\nc = Client(model)\npr = \"create a user for sarah adams, email sarah@gmail.com, and give them a strong password\"\nr = c(pr, tools=[User.claude_schema()], tool_choice=mk_tool_choice('User'))\ncts = contents(r)\nmod = call_func(cts, ns=[User])\nmod\n\nUser(username='sarahadams', password='X9#mK2$pL7@qR4', email='sarah@gmail.com', success=True, failure_reason='')\n\n\nAnd creating a new chat messages:\n\nmk_msg([mk_funcres(cts.id, mod)])\n\n{'role': 'user',\n 'content': [{'type': 'tool_result',\n   'tool_use_id': 'toolu_01KUWkLVxiwnkVJPybTbod9f',\n   'content': \"username='sarahadams' password='X9#mK2$pL7@qR4' email='sarah@gmail.com' success=True failure_reason=''\"}]}\n\n\nLet’s create a nicer function that wraps the Chat.__call__. This takes an unintialized Pydantic BaseModel and returns an initialized BaseModel.\n\nsource\n\n\nClient.struct\n\n Client.struct (msgs:list, resp_model:type[pydantic.main.BaseModel],\n                sp='', temp=0, maxtok=4096, prefill='', stream:bool=False,\n                stop=None, tools:Optional[list]=None,\n                tool_choice:Optional[dict]=None,\n                metadata:MetadataParam|NotGiven=NOT_GIVEN,\n                stop_sequences:List[str]|NotGiven=NOT_GIVEN, system:Union[\n                str,Iterable[TextBlockParam]]|NotGiven=NOT_GIVEN,\n                temperature:float|NotGiven=NOT_GIVEN,\n                top_k:int|NotGiven=NOT_GIVEN,\n                top_p:float|NotGiven=NOT_GIVEN,\n                extra_headers:Headers|None=None,\n                extra_query:Query|None=None, extra_body:Body|None=None,\n                timeout:float|httpx.Timeout|None|NotGiven=NOT_GIVEN)\n\nParse Claude output into the Pydantic resp_model\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmsgs\nlist\n\nList of messages in the dialog\n\n\nresp_model\ntype\n\nNon-initialized pydantic struct\n\n\nsp\nstr\n\nThe system prompt\n\n\ntemp\nint\n0\nTemperature\n\n\nmaxtok\nint\n4096\nMaximum tokens\n\n\nprefill\nstr\n\nOptional prefill to pass to Claude as start of its response\n\n\nstream\nbool\nFalse\nStream response?\n\n\nstop\nNoneType\nNone\nStop sequence\n\n\ntools\nOptional\nNone\nList of tools to make available to Claude\n\n\ntool_choice\nOptional\nNone\nOptionally force use of some tool\n\n\nmetadata\nMetadataParam | NotGiven\nNOT_GIVEN\n\n\n\nstop_sequences\nList[str] | NotGiven\nNOT_GIVEN\n\n\n\nsystem\nUnion[str, Iterable[TextBlockParam]] | NotGiven\nNOT_GIVEN\n\n\n\ntemperature\nfloat | NotGiven\nNOT_GIVEN\n\n\n\ntop_k\nint | NotGiven\nNOT_GIVEN\n\n\n\ntop_p\nfloat | NotGiven\nNOT_GIVEN\n\n\n\nextra_headers\nHeaders | None\nNone\n\n\n\nextra_query\nQuery | None\nNone\n\n\n\nextra_body\nBody | None\nNone\n\n\n\ntimeout\nfloat | httpx.Timeout | None | NotGiven\nNOT_GIVEN\n\n\n\nReturns\nBaseModel\n\nInitialized pydantic struct\n\n\n\n\n\nExported source\n@patch\n@delegates(Client.__call__)\ndef struct(self:Client,\n             msgs:list, # List of messages in the dialog\n             resp_model: type[BaseModel], # Non-initialized pydantic struct\n             **kwargs\n          ) -&gt; BaseModel: # Initialized pydantic struct\n    \"Parse Claude output into the Pydantic `resp_model`\"\n    kwargs[\"tool_choice\"] = mk_tool_choice(resp_model.__name__)\n    kwargs[\"tools\"] = [resp_model.claude_schema()] # no other tools needed -- model is forced by tool_choice\n    fc = self(msgs=msgs, **kwargs)\n    res = _mk_struct(contents(fc).input, resp_model)\n    return res\n\n\nThis will always return a BaseModel “struct”\n\nc.struct(pr, resp_model=User)\n\nUser(username='sarahadams', password='X9#mK2$pL7@qR4', email='sarah@gmail.com', success=True, failure_reason='')\n\n\nEven if we try not to:\n\nc.struct('what is 2+2', resp_model=User)\n\nUser(username='&lt;UNKNOWN&gt;', password='&lt;UNKNOWN&gt;', email='&lt;UNKNOWN&gt;', success=False, failure_reason=\"The query is unrelated to user creation. It's a simple arithmetic question.\")\n\n\nNow let’s implement this in Chat. The most non-invasive way I can think of to do this is add a new struct function that adds the function result to the history\n\nsource\n\n\nChat.struct\n\n Chat.struct (resp_model:type[pydantic.main.BaseModel],\n              treat_as_output=True, sp='', temp=0, maxtok=4096,\n              prefill='', stream:bool=False, stop=None,\n              tools:Optional[list]=None, tool_choice:Optional[dict]=None,\n              metadata:MetadataParam|NotGiven=NOT_GIVEN,\n              stop_sequences:List[str]|NotGiven=NOT_GIVEN, system:Union[st\n              r,Iterable[TextBlockParam]]|NotGiven=NOT_GIVEN,\n              temperature:float|NotGiven=NOT_GIVEN,\n              top_k:int|NotGiven=NOT_GIVEN,\n              top_p:float|NotGiven=NOT_GIVEN,\n              extra_headers:Headers|None=None,\n              extra_query:Query|None=None, extra_body:Body|None=None,\n              timeout:float|httpx.Timeout|None|NotGiven=NOT_GIVEN)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nresp_model\ntype\n\nNon-initialized pydantic struct\n\n\ntreat_as_output\nbool\nTrue\nUsually using a tool\n\n\nsp\nstr\n\nThe system prompt\n\n\ntemp\nint\n0\nTemperature\n\n\nmaxtok\nint\n4096\nMaximum tokens\n\n\nprefill\nstr\n\nOptional prefill to pass to Claude as start of its response\n\n\nstream\nbool\nFalse\nStream response?\n\n\nstop\nNoneType\nNone\nStop sequence\n\n\ntools\nOptional\nNone\nList of tools to make available to Claude\n\n\ntool_choice\nOptional\nNone\nOptionally force use of some tool\n\n\nmetadata\nMetadataParam | NotGiven\nNOT_GIVEN\n\n\n\nstop_sequences\nList[str] | NotGiven\nNOT_GIVEN\n\n\n\nsystem\nUnion[str, Iterable[TextBlockParam]] | NotGiven\nNOT_GIVEN\n\n\n\ntemperature\nfloat | NotGiven\nNOT_GIVEN\n\n\n\ntop_k\nint | NotGiven\nNOT_GIVEN\n\n\n\ntop_p\nfloat | NotGiven\nNOT_GIVEN\n\n\n\nextra_headers\nHeaders | None\nNone\n\n\n\nextra_query\nQuery | None\nNone\n\n\n\nextra_body\nBody | None\nNone\n\n\n\ntimeout\nfloat | httpx.Timeout | None | NotGiven\nNOT_GIVEN\n\n\n\nReturns\nBaseModel\n\nInitialized pydantic struct\n\n\n\n\n\nExported source\n@patch\n@delegates(Client.struct)\ndef struct(self:Chat,\n             resp_model: type[BaseModel], # Non-initialized pydantic struct\n             treat_as_output=True, # Usually using a tool\n             **kwargs) -&gt; BaseModel:\n    self._append_pr(kwargs.pop(\"pr\", None))\n    res = self.c.struct(self.h, resp_model=resp_model, **kwargs)\n    if treat_as_output:\n        msgs = [mk_msg(repr(res), \"assistant\")] # alternatively: res.json()\n    else:\n        r = self.c.result\n        tool_id = contents(r).id\n        msgs = [mk_msg(r, \"assistant\"),\n                mk_msg([mk_funcres(tool_id, repr(res))], \"user\")]\n    self.h += msgs\n    return res\n\n\n\ngen_pass = True\ndef generate_password() -&gt; dict:\n    \"\"\"generate a strong user password.\n\n    @returns { \"success\": &lt;indicates function success&gt;, \"pass\": &lt;password&gt; }\n    \"\"\"\n    if gen_pass:\n        return {\"success\": True, \"pass\": \"qwerty123\"}\n    return {\"success\": False, \"pass\": \"&lt;UNKNOWN&gt;\"}\n\nsp = \"\"\"You are a user generation system.\nRefer to only the **most recent** user generation request. Do not attend to previous requests.\n\n&lt;instructions&gt;\n1. If creating a user with only an email, pick a relevant username.\n  a) If no email is given, fail user creation. Do not ask for more information.\n2. You must use `generate_password` tool to create passwords. You must NOT create your own passwords.\n  a) if `generate_password` returns `success=False` and `pass=&lt;UNKNOWN&gt;` fail user creation.\n3. If you are given `tool_choice=User`, refer to &lt;user_creation&gt; for your response. Else respond in plain english.\n&lt;/instructions&gt;\n\n&lt;user_creation&gt;\nif user creation is successful:\n    create user using the `User` tool\nelse: # user creation has failed\n    refer to &lt;fail_user&gt;\n&lt;/user_creation&gt;\n\n&lt;fail_user&gt;\nThis should only be run if and only if `User` is given in `tool_choice` and user creation has failed.\n\n1. Mark failed fields as &lt;UNKNOWN&gt;\n2. Set `success = False`\n3. Give relevant details for failure in `failure_reason`\n&lt;/fail_user&gt;\n\"\"\"\n\nchat = Chat(model, tools=[generate_password], sp=sp, cont_pr=\"use the tool specified\")\nchat(\"create a user with username jackAdam12 and email jack@email.com\")\n\nCertainly! I’ll create a user with the username jackAdam12 and email jack@email.com. To do this, we need to generate a strong password using the generate_password function. Let’s proceed with the user creation process.\n\n\nid: msg_019SpTmBh9LtM7tERkY4Rxko\ncontent: [{‘text’: “Certainly! I’ll create a user with the username jackAdam12 and email jack@email.com. To do this, we need to generate a strong password using the generate_password function. Let’s proceed with the user creation process.”, ‘type’: ‘text’}, {‘id’: ‘toolu_01LHxVZsNKUSpfkvHGa5u9BX’, ‘input’: {}, ‘name’: ‘generate_password’, ‘type’: ‘tool_use’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: tool_use\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 681, ‘output_tokens’: 89}\n\n\n\n\n\nchat.struct(User)\n\nUser(username='jackAdam12', password='qwerty123', email='jack@email.com', success=True, failure_reason='')\n\n\nNow let’s make the gen_pass function fail:\n\ngen_pass = False\nprint(generate_password())\nchat('cool, can you create another user for sarahjones@gmail.com?')\n\n{'success': False, 'pass': '&lt;UNKNOWN&gt;'}\n\n\nCertainly! I’ll create a user for sarahjones@gmail.com. Since only the email was provided, I’ll generate a relevant username based on the email address. Then, we’ll use the generate_password function to create a secure password for this user.\nFirst, let’s generate the password:\n\n\nid: msg_01S6SUDmhmrDKns5nxZRc9Ae\ncontent: [{‘text’: “Certainly! I’ll create a user for sarahjones@gmail.com. Since only the email was provided, I’ll generate a relevant username based on the email address. Then, we’ll use the generate_password function to create a secure password for this user., let’s generate the password:”, ‘type’: ‘text’}, {‘id’: ‘toolu_018LXGQEsMjhEZzrwyW2eJ5b’, ‘input’: {}, ‘name’: ‘generate_password’, ‘type’: ‘tool_use’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: tool_use\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 1080, ‘output_tokens’: 103}\n\n\n\n\nWe get a user creation failure with an appropiate failure message.\n\nchat.struct(User)\n\nUser(username='sarahjones', password='&lt;UNKNOWN&gt;', email='sarahjones@gmail.com', success=False, failure_reason='Unable to generate a secure password')\n\n\nFinally let’s try to create a user with no email:\n\ngen_pass = True\nchat('finally can you create an account for Adam?')\n\nI apologize, but I’m unable to create an account for Adam with just the name provided. To create a user account, we need at least an email address. Without an email address, I cannot proceed with the user creation process as per the instructions I’ve been given.\nHere’s why I can’t create the account:\n\nAn email address is a required piece of information for user creation.\nWe don’t have enough information to generate a unique username or to associate the account with a valid email address.\nThe instructions specifically state that if no email is given, we should fail user creation and not ask for more information.\n\nIf you’d like to create an account for Adam, you would need to provide at least an email address. Once you have an email address for Adam, please feel free to ask again, and I’ll be happy to assist you with creating the account.\nIs there anything else I can help you with, or would you like to provide an email address for Adam to proceed with account creation?\n\n\nid: msg_01EHSXCJ4nACtApWNT89fdmy\ncontent: [{‘text’: “I apologize, but I’m unable to create an account for Adam with just the name provided. To create a user account, we need at least an email address. Without an email address, I cannot proceed with the user creation process as per the instructions I’ve been given.‘s why I can’t create the account:. An email address is a required piece of information for user creation.. We don’t have enough information to generate a unique username or to associate the account with a valid email address.. The instructions specifically state that if no email is given, we should fail user creation and not ask for more information.you’d like to create an account for Adam, you would need to provide at least an email address. Once you have an email address for Adam, please feel free to ask again, and I’ll be happy to assist you with creating the account.there anything else I can help you with, or would you like to provide an email address for Adam to proceed with account creation?“, ’type’: ‘text’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 1655, ‘output_tokens’: 217}\n\n\n\n\n\nchat.struct(User)\n\nUser(username='Adam', password='&lt;UNKNOWN&gt;', email='&lt;UNKNOWN&gt;', success=False, failure_reason='Insufficient information provided: missing email address and password')",
    "crumbs": [
      "Structured Output with Pydantic"
    ]
  }
]